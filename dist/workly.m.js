function t(t){let n,o;if("function"==typeof t){const e=Function.prototype.toString;n=o=URL.createObjectURL(new Blob([`${e.call(r)}\n(${e.call(s)})(${e.call(t)})`]))}else"string"==typeof t&&(n=t,0===t.indexOf("blob:")&&(o=n));if(n){let t=new Worker(n);return o&&(t.oURL=o),e(new a(t))}throw"Workly only supports functions, classes, urls"}function e(t,a){return a=a||[],new Proxy(function(){},{get(r,s,n){if("then"===s){if(0===a.length)return{then:()=>n};const e=t.remote({type:"GET",path:a});return e.then.bind(e)}return e(t,a.concat(s))},set:(e,r,s)=>t.remote({type:"SET",path:a.concat(r),value:s}),apply:(e,r,s)=>t.remote({type:"APPLY",path:a,args:s}),construct:(e,a)=>t.remote({type:"CONSTRUCT",args:a})})}class a{constructor(t,s){this.w=t,this.uid=s||`${Date.now()}-${r()}`,this.c=0,this.cbs={},t.addEventListener("message",r=>{if(this.w.oURL)try{URL.revokeObjectURL(this.w.oURL)}catch(t){}finally{delete this.w.oURL}let s=r.data&&r.data.id,n=s&&this.cbs[s];n&&(delete this.cbs[s],r.data.error?n[1](new Error(r.data.error)):n[0](r.data.targetId?e(new a(t,r.data.targetId)):r.data.value))})}remote(t){const e=t.args||[],a=`${this.uid}-${++this.c}`;return new Promise((r,s)=>{this.cbs[a]=[r,s],this.w.postMessage(Object.assign({},t,{id:a,args:e,target:this.uid}))})}}function r(){return Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)}function s(t){const e=t,a={};self.addEventListener("message",async t=>{let s=t.data||{};s.path=s.path||[];let n=s.target&&a[s.target]||e;const o=t=>t.reduce((t,e)=>t?t[e]:t,n),c=s&&s.id;if(c&&s.type){const t={id:c},e=o(s.path),n=o(s.path.slice(0,-1));switch(s.type){case"GET":t.value=e;break;case"SET":let o=s.path.length&&s.path[s.path.length-1];o&&(n[o]=s.value),t.value=!!o;break;case"APPLY":try{t.value=await e.apply(n,s.args||[])}catch(e){t.error=e.toString()}break;case"CONSTRUCT":try{t.value=new e(...s.args),t.targetId=(t=>{const e=`${Date.now()}-${r()}`;return a[e]=t,e})(t.value)}catch(e){t.error=e.toString()}}self.postMessage(t)}})}export{t as proxy,s as expose};
